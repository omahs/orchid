// @dart=2.9
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:orchid/api/vpn/orchid_api.dart';
import 'package:orchid/api/vpn/orchid_api_real.dart';
import 'package:orchid/api/preferences/user_preferences.dart';
import 'package:orchid/pages/app_routes.dart';
import 'package:orchid/pages/purchase/purchase_page.dart';
import 'package:rxdart/rxdart.dart';
import 'package:sqflite/sqflite.dart';
import '../monitoring/analysis_db.dart';
import '../monitoring/restart_manager.dart';
import '../orchid_log.dart';

///
/// Mock Orchid App Channel API Implementation
///
class MockOrchidAPI implements OrchidAPI {
  static final MockOrchidAPI _singleton = MockOrchidAPI._internal();

  factory MockOrchidAPI() {
    return _singleton;
  }

  MockOrchidAPI._internal() {
    log("Constructed Mock API");
    _initChannel();
  }

  /// Publish the connection status.
  final vpnExtensionStatus = BehaviorSubject<OrchidVPNExtensionState>();

  /// Publish the orchid network connection status.
  final BehaviorSubject<OrchidVPNRoutingState> vpnRoutingStatus =
      BehaviorSubject<OrchidVPNRoutingState>.seeded(
          OrchidVPNRoutingState.VPNNotConnected);

  /// Publishes a status of true if the user has granted any necessary OS level permissions to allow
  /// installation and activation of the Orchid VPN networking extension.
  /// Note: On iOS this corresponds to having successfully saved the Orchid VPN configuration via the
  /// NEVPNManager API.
  final vpnPermissionStatus = BehaviorSubject<bool>();

  final circuitConfigurationChanged = BehaviorSubject<void>.seeded(null);

  /// Initialize the Channel implementation.
  /// This method is called once when the application is initialized.
  void _initChannel() {
    // init connection status
    vpnExtensionStatus.add(OrchidVPNExtensionState.NotConnected);

    // Update the orchid routing status when the vpn or (mock) orchid
    // tunnel connection state changes.
    vpnExtensionStatus.listen((OrchidVPNExtensionState state) {
      var applyRoutingStatus = RealOrchidAPI.applyRoutingStatus;
      switch (state) {
        case OrchidVPNExtensionState.Invalid:
        case OrchidVPNExtensionState.NotConnected:
          applyRoutingStatus(OrchidVPNRoutingState.VPNNotConnected);
          break;
        case OrchidVPNExtensionState.Connecting:
          applyRoutingStatus(OrchidVPNRoutingState.VPNConnecting);
          break;

        case OrchidVPNExtensionState.Connected:
          applyRoutingStatus(OrchidVPNRoutingState.VPNConnected);

          // Mock orchid routing if routing is enabled.
          var routing = UserPreferences().routingEnabled.get();
          if (routing) {
            Future.delayed(Duration(seconds: 1), () {
              applyRoutingStatus(OrchidVPNRoutingState.OrchidConnected);
            });
          }

          break;
        case OrchidVPNExtensionState.Disconnecting:
          applyRoutingStatus(OrchidVPNRoutingState.VPNDisconnecting);
          break;
      }
    });

    // vpn configuration / permission status
    vpnPermissionStatus.add(false);

    // fake monitoring traffic data
    UserPreferences().monitoringEnabled.stream().listen((monitoring) {
      if (monitoring) {
        insertMockTrafficData();
      }
    });
  }

  static Future<Database> initInMemoryAnalysisDb() async {
    log("mock: initInMemoryAnalysisDb");
    var db = await openDatabase(':memory', readOnly: false);
    // should match capture.cpp
    var createTable = 'create table "flow" ('
        '"id" integer primary key autoincrement,'
        '"start" real,'
        '"layer4" integer,'
        '"src_addr" integer,'
        '"src_port" integer,'
        '"dst_addr" integer,'
        '"dst_port" integer,'
        '"protocol" string,'
        '"hostname" text'
        ')';
    try {
      await db.execute(createTable);
    } catch (err) {
      log("mock: create table error in mock db: $err");
    }
    return db;
  }

  static bool insertedMockTrafficData = false;

  Future<void> insertMockTrafficData() async {
    if (insertedMockTrafficData) {
      return;
    }
    insertedMockTrafficData = true;
    log("mock: insertMockTrafficData");
    var db = await AnalysisDb().getDb();
    var inserts = """
-- INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.3656754512,6,168230915,62133,-1395063294,443,'TCP','test.really.long.item.foo.g.blah.gee.gah.net');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.365221146,1,168230915,0,134744072,0,'ICMP',NULL);
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.3656754512,6,168230915,62133,-1395063294,443,'TCP','googleads.g.doubleclick.net');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.3657346875,6,168230915,64825,1823570364,5228,'TCP','mtalk.google.com');
-- INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.365790799,6,168230915,62160,301799886,443,'TCP','mesu.apple.com');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.365607905,17,168230915,63400,134744072,53,'DNS',NULL);
-- INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.365795197,6,168230915,62162,-1377888904,443,'TCP','configuration.apple.com');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.355807072,6,168230915,62170,-1645211101,443,'TCP','www.facebook.com');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.365855324,6,168230915,62186,1666514438,443,'TCP','www.orchid.com');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.3722021645,17,168230915,60095,-268435462,1900,'HTTP/1.1','239.255.255.250:1900');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.3722152663,6,168230915,62248,-1395062454,443,'TCP','youtubei.googleapis.com');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.3722716896,6,168230915,49653,-1379745172,993,'TCP','imap.gmail.com');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.3774122684,6,168230915,62258,1666514598,443,'TCP','slack.com');
INSERT INTO flow(start,layer4,src_addr,src_port,dst_addr,dst_port,protocol,hostname) VALUES (2458712.3774122684,6,168230915,62258,1666514598,443,'TLS','slack.com');
    """;
    var statements = inserts.trim().split('\n');
    // The :memory: db persists across reboots if not closed?
    await db.rawDelete('delete from flow');
    for (var statement in statements) {
      if (!statement.startsWith('--')) {
        await db.rawInsert(statement);
      }
    }
  }

  /// The Flutter application uses this method to indicate to the native channel code
  /// that the UI has finished launching and all listeners have been established.
  Future<void> applicationReady() async {
    // Monitor user preferences and start or stop the VPN extension.
    await OrchidRestartManager().initVPNControlListener();
    return null;
  }

  static bool hidePrices = const bool.fromEnvironment('hide_prices');

  /// Check for startup args. e.g. for screenshot rigging.
  static void checkStartupCommandArgs(BuildContext context) async {
    log("Check command args");

    // TODO: This should be updated to import a circuit config.
    // Allow setting the account for screenshots
    // Must use 'const' here:  https://github.com/flutter/flutter/issues/55870
    /*
    const identity = String.fromEnvironment('identity', defaultValue: null);
    if (identity != null) {
      try {
        setDefaultIdentityFromString(identity);
      } catch (err) {
        log("Error setting default identity from string: $err");
      }
    }
     */

    // Set connected status
    const connected = bool.fromEnvironment('connected', defaultValue: null);
    if (connected != null) {
      fakeVPNDelay = 0;
      UserPreferences().routingEnabled.set(connected);
    }

    // Push to named screen
    const showScreen = String.fromEnvironment('screen');
    if (showScreen == 'accounts') {
      await Navigator.pushNamed(context, AppRoutes.account_manager);
    } else if (showScreen == 'purchase') {
      Navigator.push(
          context,
          MaterialPageRoute(
              fullscreenDialog: true,
              builder: (BuildContext context) {
                return PurchasePage(
                    signerKey: null,
                    cancellable: true,
                    completion: () {
                      log("purchase complete");
                    });
              }));
    } else if (showScreen == 'traffic') {
      await UserPreferences().monitoringEnabled.set(true);
      await Navigator.pushNamed(context, AppRoutes.traffic);
    } else if (showScreen == 'circuit') {
      await Navigator.pushNamed(context, AppRoutes.circuit);
    }
  }

  /*
  /// Import an identity and set it as the default.
  static void setDefaultIdentityFromString(String config) async {
    log("xxx: set default identity from string: $config");
    var existingKeys = await UserPreferences().getKeys();
    var result =
        OrchidAccountImport.parseOrchidIdentity(config, existingKeys);
    if (result.isNew) {
      await UserPreferences().addKey(result.signer);
    }

    // Do wait for account discovery
    var accountStore = AccountStore();
    // Set it as the active identity and pick the first account found
    await accountStore.setActiveIdentity(result.signer);
    await accountStore.load();
    try {
      await accountStore.setActiveAccount(accountStore.accounts.first);
    } catch (err) {
      log("set default identity: unable to find account: $err");
    }
  }
   */

  /// Get the logging API.
  @override
  OrchidLogAPI logger() {
    return OrchidLogAPI.defaultLogAPI;
  }

  /// Trigger a request for OS level permissions required to allow installation and activation of the
  /// Orchid VPN networking extension, potentially causing the OS to prompt the user.
  /// Returns true if the permission was granted.
  /// Note: On iOS this corresponds to an attempt to save the Orchid VPN configuration via the
  /// NEVPNManager API.
  @override
  Future<bool> requestVPNPermission() async {
    vpnPermissionStatus.add(true);
    return true;
  }

  /// Remove the VPN networking extension.
  Future<void> revokeVPNPermission() async {
    OrchidAPI().vpnPermissionStatus.add(false);
  }

  Timer _connectFuture;

  static int fakeVPNDelay = 3000;

  /// Set the desired connection state: true for connected, false to disconnect.
  /// Note: This mock shows the connecting state for N seconds and then connects
  /// Note: successfully.
  @override
  Future<void> setVPNExtensionEnabled(bool enabled) async {
    log("mock: setVPNExtensionEnabled = $enabled, vpnConnectionStatus = ${vpnExtensionStatus.value}");
    switch (vpnExtensionStatus.value) {
      case OrchidVPNExtensionState.Invalid:
      case OrchidVPNExtensionState.NotConnected:
      case OrchidVPNExtensionState.Disconnecting:
        // Cancel any pending connect or disconnect
        if (_connectFuture != null) {
          _connectFuture.cancel();
          _connectFuture = null;
        }

        if (enabled) {
          _setConnectionState(OrchidVPNExtensionState.Connecting);

          _connectFuture = Timer(Duration(milliseconds: fakeVPNDelay), () {
            _setConnectionState(OrchidVPNExtensionState.Connected);
          });
        } else {
          return; // redundant disconnect
        }
        break;
      case OrchidVPNExtensionState.Connecting:
      case OrchidVPNExtensionState.Connected:
        // Cancel any pending connect or disconnect
        if (_connectFuture != null) {
          _connectFuture.cancel();
          _connectFuture = null;
        }
        if (enabled) {
          // redundant connect
          return;
        } else {
          _setConnectionState(OrchidVPNExtensionState.Disconnecting);
          _connectFuture = Timer(Duration(milliseconds: fakeVPNDelay), () {
            _setConnectionState(OrchidVPNExtensionState.NotConnected);
          });
        }

        break;
    }
  }

  void _setConnectionState(OrchidVPNExtensionState state) {
    logger().write('Connection state: $state');
    vpnExtensionStatus.add(state);
  }

  Future<String> groupContainerPath() async {
    return 'mock-no-container';
  }

  /// The build version
  Future<String> versionString() async {
    return "1.0.0";
  }

  /// Publish the latest configuration to the VPN.
  Future<bool> publishConfiguration() async {
    log("mock: update configuration");
    var combinedConfig = await RealOrchidAPI.generateCombinedConfig();
    log("mock: combinedConfig = $combinedConfig");
    // Do nothing.
    return true;
  }

  void dispose() {
    vpnExtensionStatus.close();
    circuitConfigurationChanged.close();
    vpnRoutingStatus.close();
    vpnPermissionStatus.close();
  }
}
